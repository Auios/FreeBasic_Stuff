<html>
<head>
<title>Operator</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div id="fb_body_wrapper">
<div id="fb_tab">
<div id="fb_tab_l">Operator</div>
<div id="fb_tab_r">&nbsp;<img src="images/fblogo_mini.gif" /></div> 
</div> 
<div id="fb_pg_wrapper">
<div id="fb_pg_body">
	Declares or defines an overloaded operator.<br \>
<br \>
<div class="fb_sect_title">Syntax</div><div class="fb_sect_cont"><tt><br \>
{ <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> | <a href="KeyPgEnum.html">Enum</a> } <i>typename</i><br \>
<div class="fb_indent"><a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgCast.html">Cast</a> () <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpAt.html">@</a> () <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <i>assignment_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpPtrIndex.html">[]</a> ( <i>index</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) [ <a href="KeyPgByrefFunction.html">ByRef</a> ] <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpNew.html">New</a> ( <i>size</i> <a href="KeyPgAs.html">As</a> <a href="KeyPgUinteger.html">UInteger</a> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpNew.html">New</a>[] ( <i>size</i> <a href="KeyPgAs.html">As</a> <a href="KeyPgUinteger.html">UInteger</a> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpDelete.html">Delete</a> ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpDelete.html">Delete</a>[] ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> )<br \>
</div>End { <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> | <a href="KeyPgEnum.html">Enum</a> }<br \>
<br \>
{ <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> } <i>typename</i><br \>
<div class="fb_indent"><a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpFor.html">For</a> ()<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpFor.html">For</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>stp</i> <a href="KeyPgAs.html">As</a> <i>typename</i> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpStep.html">Step</a> ()<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpStep.html">Step</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>stp</i> <a href="KeyPgAs.html">As</a> <i>typename</i> )<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpNext.html">Next</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>cond</i> <a href="KeyPgAs.html">As</a> <i>typename</i> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgInteger.html">Integer</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <a href="KeyPgOpNext.html">Next</a> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>cond</i> <a href="KeyPgAs.html">As</a> <i>typename</i>, [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>stp</i> <a href="KeyPgAs.html">As</a> <i>typename</i> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgInteger.html">Integer</a><br \>
</div>End { <a href="KeyPgType.html">Type</a> | <a href="KeyPgClass.html">Class</a> | <a href="KeyPgUnion.html">Union</a> }<br \>
<br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <i>unary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<a href="KeyPgDeclare.html">Declare</a> <b>Operator</b> <i>binary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>lhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a>, [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgCast.html">Cast</a> () <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpAt.html">@</a> () <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<b>Operator</b> <i>typename</i>.<i>assignment_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> )<br \>
<b>Operator</b> <a href="KeyPgOpPtrIndex.html">[]</a> ( <i>index</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) [ <a href="KeyPgByrefFunction.html">ByRef</a> ] <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<b>Operator</b> <i>unary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<b>Operator</b> <i>binary_op</i> ( [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>lhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a>, [ <a href="KeyPgByref.html">ByRef</a> | <a href="KeyPgByval.html">ByVal</a> ] <i>rhs</i> <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a> ) <a href="KeyPgAs.html">As</a> <a href="DataType.html">datatype</a><br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpNew.html">New</a> ( <i>size</i> as uinteger ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpNew.html">New</a>[] ( <i>size</i> <a href="KeyPgAs.html">As</a> <a href="KeyPgUinteger.html">UInteger</a> ) <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a><br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpDelete.html">Delete</a> ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> )<br \>
<b>Operator</b> <i>typename</i>.<a href="KeyPgOpDelete.html">Delete</a>[] ( <i>buf</i>  <a href="KeyPgAs.html">As</a> <a href="KeyPgAny.html">Any</a> <a href="KeyPgPtr.html">Ptr</a> )<br \>
</tt><br \>
</div><div class="fb_sect_title">Parameters</div><div class="fb_sect_cont"><br \>
<tt><i>typename</i></tt> <br \>
<div class="fb_indent">Name of the <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, <tt><a href="KeyPgUnion.html">Union</a></tt>, or <tt><a href="KeyPgEnum.html">Enum</a></tt>.<br \>
</div><tt><i>assignment_op</i></tt> <br \>
<div class="fb_indent"><tt>let += -= *= &= /= \= mod= shl= shr= and= or= xor= imp= eqv= ^=</tt><br \>
</div><tt><i>unary_op</i></tt><br \>
<div class="fb_indent"><tt>- not * -&gt; abs sgn fix frac int exp log sin asin cos acos tan atn len</tt><br \>
</div><tt><i>binary_op</i></tt><br \>
<div class="fb_indent"><tt>+ - * & / \ mod shl shr and or xor imp eqv ^ = &lt;&gt; &lt; &gt; &lt;= &gt;=</tt><br \>
<br \>
</div></div><div class="fb_sect_title">Description</div><div class="fb_sect_cont"><br \>
The built in operators like <tt>=</tt>, <tt>+</tt>, and <tt>cast</tt> have predefined behaviors when used in expressions.  These operators can be overloaded to do something other than predefined operations when at least one of the arguments to the operator is a <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, <tt><a href="KeyPgEnum.html">Enum</a></tt>, or <tt><a href="KeyPgUnion.html">Union</a></tt> data type.<br \>
<br \>
Operators are just functions.  The operator '+' has functionality like <tt>Function Plus( A as DataType, B as DataType ) as DataType</tt>.  See <i><a href="ProPgOperatorOverloading.html">Operator Overloading</a></i> for more information.  Operators can be overloaded to accept different data types as parameters.  The <tt><a href="KeyPgCast.html">Cast</a></tt> Operator is the only operator (or function) that can be declared multiple times when only the return type differs (for not explicit usage, the compiler may decide which cast overload to call based on how the object is used).<br \>
<br \>
Non-static operator members are declared inside the <tt><a href="KeyPgType.html">Type</a></tt> or <tt><a href="KeyPgClass.html">Class</a></tt>.  Global operators are declared outside.  All operator definitions (procedure bodies) must appear outside.<br \>
<br \>
<tt><b>Let</b></tt>, <tt><b>Cast</b></tt>, and other assignment operators must be declared inside the <tt><a href="KeyPgType.html">Type</a></tt> or <tt><a href="KeyPgClass.html">Class</a></tt>.  They are passed a hidden <tt><a href="KeyPgThis.html">This</a></tt> parameter and have a return data type same as the <tt><a href="KeyPgType.html">Type</a></tt> or <tt><a href="KeyPgClass.html">Class</a></tt> they are declared in.<br \>
<br \>
Unary operators must be declared outside the <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, or <tt><a href="KeyPgEnum.html">Enum</a></tt> and have a return data type explicitly declared.  Unary operators can be overloaded to return any valid data type, except for <tt><a href="KeyPgOpPtrMemberAccess.html">Operator -&gt; (Pointer To Member Access)</a></tt> which must return a <tt><a href="KeyPgType.html">Type</a></tt> or <tt><a href="KeyPgClass.html">Class</a></tt> data type.<br \>
<br \>
Binary operators must be declared outside the <tt><a href="KeyPgType.html">Type</a></tt>, <tt><a href="KeyPgClass.html">Class</a></tt>, or <tt><a href="KeyPgEnum.html">Enum</a></tt> and have a return data type explicitly declared.  Binary operators can be overloaded with valid data types, except for relational operators, which must return <tt><a href="KeyPgInteger.html">Integer</a></tt>.<br \>
<br \>
<tt><a href="KeyPgLet.html">Let</a></tt> refers to the assignment operator, as in <tt>LET a=b</tt>. The <tt><a href="KeyPgLet.html">Let</a></tt> keyword is omitted in common practice, and is not allowed in the <i><a href="CompilerOptlang.html">-lang fb</a></i> dialect.  However, <tt><a href="KeyPgOpLetlist.html">Let()</a></tt> can be used to assign the fields of a UDT to multiple variables.<br \>
<br \>
See <tt><a href="KeyPgOpFor.html">For</a></tt>, <tt><a href="KeyPgOpStep.html">Step</a></tt>, and <tt><a href="KeyPgOpNext.html">Next</a></tt> for more information on overloading the <tt><a href="KeyPgFornext.html">For..Next</a></tt> statement for use with user defined types.<br \>
<br \>
<tt><b>New</b></tt>, <tt><b>New[]</b></tt>, <tt><b>Delete</b></tt>, and <tt><b>Delete[]</b></tt> operator members are always static, even if not explicitly declared (<tt><a href="KeyPgStaticMember.html">Static</a></tt> keyword is unnecessary but allowed).<br \>
<br \>
</div><div class="fb_sect_title">Example</div><div class="fb_sect_cont"><br \>
<tt><div class="freebasic">
<span class="com">''&nbsp;operator1.bas</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">Vector2D</span><br />
&nbsp;&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span>&nbsp;<span class="wrd">x</span><span class="oth">,</span>&nbsp;<span class="wrd">y</span><br />
<br />
&nbsp;&nbsp;<span class="com">''&nbsp;Return&nbsp;a&nbsp;string&nbsp;containing&nbsp;the&nbsp;vector&nbsp;data.</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Cast</span><span class="oth">()</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">String</span><br />
<br />
&nbsp;&nbsp;<span class="com">''&nbsp;Multiply&nbsp;the&nbsp;vector&nbsp;by&nbsp;a&nbsp;scalar.</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="oth">*=</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByVal</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span>&nbsp;<span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="com">''&nbsp;Allow&nbsp;two&nbsp;vectors&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;be&nbsp;added&nbsp;together.</span><br />
<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">lhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><span class="oth">,</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><br />
<br />
<span class="com">''&nbsp;Return&nbsp;the&nbsp;modulus&nbsp;(single)&nbsp;of&nbsp;the&nbsp;vector&nbsp;using&nbsp;the&nbsp;overloaded&nbsp;operator&nbsp;abs().</span><br />
<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Abs</span>&nbsp;<span class="oth">(</span>&nbsp;&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="wrd">Vector2D.cast</span>&nbsp;<span class="oth">()</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">String</span><br />
&nbsp;&nbsp;<span class="key">Return</span>&nbsp;<span class="quo">"("</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="key">Str</span><span class="oth">(</span><span class="wrd">x</span><span class="oth">)</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="quo">",&nbsp;"</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="key">Str</span><span class="oth">(</span><span class="wrd">y</span><span class="oth">)</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="quo">")"</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="wrd">Vector2D.</span><span class="oth">*=</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByVal</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span>&nbsp;<span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">This.x</span>&nbsp;<span class="oth">*=</span>&nbsp;<span class="wrd">rhs</span><br />
&nbsp;&nbsp;<span class="wrd">This.y</span>&nbsp;<span class="oth">*=</span>&nbsp;<span class="wrd">rhs</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">lhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><span class="oth">,</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span><br />
&nbsp;&nbsp;<span class="key">Return</span>&nbsp;<span class="key">Type</span><span class="oth">&lt;</span><span class="wrd">Vector2D</span><span class="oth">&gt;(</span>&nbsp;<span class="wrd">lhs.x</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">rhs.x</span><span class="oth">,</span>&nbsp;<span class="wrd">lhs.y</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">rhs.y</span>&nbsp;<span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="key">Abs</span>&nbsp;<span class="oth">(</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Single</span><br />
&nbsp;&nbsp;<span class="key">Return</span>&nbsp;<span class="key">Sqr</span><span class="oth">(</span>&nbsp;<span class="wrd">rhs.x</span>&nbsp;<span class="oth">*</span>&nbsp;<span class="wrd">rhs.x</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">rhs.y</span>&nbsp;<span class="oth">*</span>&nbsp;<span class="wrd">rhs.y</span>&nbsp;<span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Dim</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">Type</span><span class="oth">&lt;</span><span class="wrd">Vector2D</span><span class="oth">&gt;(</span>&nbsp;<span class="num">1.2</span><span class="oth">,</span>&nbsp;<span class="num">3.4</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Dim</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">Type</span><span class="oth">&lt;</span><span class="wrd">Vector2D</span><span class="oth">&gt;(</span>&nbsp;<span class="num">8.9</span><span class="oth">,</span>&nbsp;<span class="num">6.7</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Dim</span>&nbsp;<span class="wrd">c</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">Vector2D</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">Type</span><span class="oth">&lt;</span><span class="wrd">Vector2D</span><span class="oth">&gt;(</span>&nbsp;<span class="num">4.3</span><span class="oth">,</span>&nbsp;<span class="num">5.6</span>&nbsp;<span class="oth">)</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="quo">"a&nbsp;=&nbsp;"</span><span class="oth">;</span>&nbsp;<span class="wrd">a</span><span class="oth">,</span>&nbsp;<span class="quo">"abs(a)&nbsp;="</span><span class="oth">;</span>&nbsp;<span class="key">Abs</span><span class="oth">(</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">"b&nbsp;=&nbsp;"</span><span class="oth">;</span>&nbsp;<span class="wrd">b</span><span class="oth">,</span>&nbsp;<span class="quo">"abs(b)&nbsp;="</span><span class="oth">;</span>&nbsp;<span class="key">Abs</span><span class="oth">(</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">"a&nbsp;+&nbsp;b&nbsp;=&nbsp;"</span><span class="oth">;</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">b</span><span class="oth">,</span>&nbsp;<span class="quo">"abs(a+b)&nbsp;="</span><span class="oth">;</span>&nbsp;<span class="key">Abs</span><span class="oth">(</span>&nbsp;<span class="wrd">a</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">b</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">"c&nbsp;=&nbsp;"</span><span class="oth">;</span>&nbsp;<span class="wrd">c</span><span class="oth">,</span>&nbsp;<span class="quo">"abs(c)&nbsp;="</span><span class="oth">;</span>&nbsp;<span class="key">Abs</span><span class="oth">(</span>&nbsp;<span class="wrd">c</span>&nbsp;<span class="oth">)</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">"'c&nbsp;*=&nbsp;3'"</span><br />
<span class="wrd">c</span>&nbsp;<span class="oth">*=</span>&nbsp;<span class="num">3</span><br />
<span class="key">Print</span>&nbsp;<span class="quo">"c&nbsp;=&nbsp;"</span><span class="oth">;</span>&nbsp;<span class="wrd">c</span><span class="oth">,</span>&nbsp;<span class="quo">"abs(c)&nbsp;="</span><span class="oth">;</span>&nbsp;<span class="key">Abs</span><span class="oth">(</span>&nbsp;<span class="wrd">c</span>&nbsp;<span class="oth">)</span><br />
</div></tt><br />
Aligned memory allocator:<br \>
<ul><ul><li> by using the overloaded member operators "New" and "Delete", any created User object is aligned to a multiple of "ALIGN" bytes (256 bytes in this example),<br \>
<li> the real pointer of the allocated memory is saved just above the User pointer, in the padding block.<br \>
</ul></ul><tt><div class="freebasic">
<span class="com">''&nbsp;operator2.bas</span><br />
<br />
<span class="key">Const</span>&nbsp;<span class="wrd">ALIGN</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">256</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">UDT</span><br />
&nbsp;&nbsp;<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Byte</span>&nbsp;<span class="wrd">a</span><span class="oth">(</span><span class="num">0</span>&nbsp;<span class="key">To</span>&nbsp;<span class="num">10</span>&nbsp;<span class="oth">*</span>&nbsp;<span class="num">1024</span>&nbsp;<span class="oth">*</span>&nbsp;<span class="num">1024</span>&nbsp;<span class="oth">-</span>&nbsp;<span class="num">1</span><span class="oth">)</span>&nbsp;<span class="com">''&nbsp;10&nbsp;megabyte&nbsp;fixed&nbsp;array</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">New</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">size</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">UInteger</span><span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Any</span>&nbsp;<span class="key">Ptr</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Delete</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">buffer</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Any</span>&nbsp;<span class="key">Ptr</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span>&nbsp;<span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Destructor</span>&nbsp;<span class="oth">()</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="wrd">UDT.New</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">size</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">UInteger</span><span class="oth">)</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Any</span>&nbsp;<span class="key">Ptr</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">"&nbsp;&nbsp;Overloaded&nbsp;New&nbsp;operator,&nbsp;with&nbsp;parameter&nbsp;size&nbsp;=&nbsp;&amp;h"</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="key">Hex</span><span class="oth">(</span><span class="wrd">size</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Dim</span>&nbsp;<span class="wrd">pOrig</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Any</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">CAllocate</span><span class="oth">(</span><span class="wrd">ALIGN</span><span class="oth">-</span><span class="num">1</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="key">SizeOf</span><span class="oth">(</span><span class="wrd">UDT</span>&nbsp;<span class="key">Ptr</span><span class="oth">)</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">size</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Dim</span>&nbsp;<span class="wrd">pMin</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Any</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">pOrig</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="key">SizeOf</span><span class="oth">(</span><span class="wrd">UDT</span>&nbsp;<span class="key">Ptr</span><span class="oth">)</span>&nbsp;<br />
&nbsp;&nbsp;<span class="key">Dim</span>&nbsp;<span class="wrd">p</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Any</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">pMin</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">ALIGN</span><span class="oth">-</span><span class="num">1</span>&nbsp;<span class="oth">-</span>&nbsp;<span class="oth">(</span><span class="key">CULng</span><span class="oth">(</span><span class="wrd">pMin</span>&nbsp;<span class="oth">+</span>&nbsp;<span class="wrd">ALIGN</span><span class="oth">-</span><span class="num">1</span><span class="oth">)</span>&nbsp;<span class="key">Mod</span>&nbsp;<span class="wrd">ALIGN</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Cast</span><span class="oth">(</span><span class="key">Any</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="key">Ptr</span><span class="oth">,</span>&nbsp;<span class="wrd">p</span><span class="oth">)[-</span><span class="num">1</span><span class="oth">]</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">pOrig</span><br />
&nbsp;&nbsp;<span class="key">Operator</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">p</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">"&nbsp;&nbsp;real&nbsp;pointer&nbsp;=&nbsp;&amp;h"</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="key">Hex</span><span class="oth">(</span><span class="wrd">pOrig</span><span class="oth">),</span>&nbsp;<span class="quo">"return&nbsp;pointer&nbsp;=&nbsp;&amp;h"</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="key">Hex</span><span class="oth">(</span><span class="wrd">p</span><span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="wrd">UDT.Delete</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">buffer</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Any</span>&nbsp;<span class="key">Ptr</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">"&nbsp;&nbsp;Overloaded&nbsp;Delete&nbsp;operator,&nbsp;with&nbsp;parameter&nbsp;buffer&nbsp;=&nbsp;&amp;h"</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="key">Hex</span><span class="oth">(</span><span class="wrd">buffer</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Dim</span>&nbsp;<span class="wrd">pOrig</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Any</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">Cast</span><span class="oth">(</span><span class="key">Any</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="key">Ptr</span><span class="oth">,</span>&nbsp;<span class="wrd">buffer</span><span class="oth">)[-</span><span class="num">1</span><span class="oth">]</span><br />
&nbsp;&nbsp;<span class="key">Deallocate</span><span class="oth">(</span><span class="wrd">pOrig</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">"&nbsp;&nbsp;real&nbsp;pointer&nbsp;=&nbsp;&amp;h"</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="key">Hex</span><span class="oth">(</span><span class="wrd">pOrig</span><span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Constructor</span>&nbsp;<span class="wrd">UDT</span>&nbsp;<span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">"&nbsp;&nbsp;Constructor,&nbsp;@This&nbsp;=&nbsp;&amp;h"</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="key">Hex</span><span class="oth">(@</span><span class="key">This</span><span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Constructor</span><br />
<br />
<span class="key">Destructor</span>&nbsp;<span class="wrd">UDT</span>&nbsp;<span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">"&nbsp;&nbsp;Destructor,&nbsp;@This&nbsp;=&nbsp;&amp;h"</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="key">Hex</span><span class="oth">(@</span><span class="key">This</span><span class="oth">)</span><br />
<span class="key">End</span>&nbsp;<span class="key">Destructor</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="quo">"'Dim&nbsp;As&nbsp;UDT&nbsp;Ptr&nbsp;p&nbsp;=&nbsp;New&nbsp;UDT'"</span><br />
<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">UDT</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="wrd">p</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">New</span>&nbsp;<span class="wrd">UDT</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="quo">"&nbsp;&nbsp;p&nbsp;=&nbsp;&amp;h"</span>&nbsp;<span class="oth">&amp;</span>&nbsp;<span class="key">Hex</span><span class="oth">(</span><span class="wrd">p</span><span class="oth">)</span><br />
<br />
<span class="key">Print</span>&nbsp;<span class="quo">"'Delete&nbsp;p'"</span><br />
<span class="key">Delete</span>&nbsp;<span class="wrd">p</span><br />
</div></tt><br />
<div class="fb_indent">Output example:<br \>
</div><pre class="fb_pre">
'Dim As UDT Ptr p = New UDT'
  Overloaded New operator, with parameter size = &hA00000
  real pointer = &h420020   return pointer = &h420100
  Constructor, @This = &h420100
  p = &h420100
'Delete p'
  Destructor, @This = &h420100
  Overloaded Delete operator, with parameter buffer = &h420100
  real pointer = &h420020
</pre>Small use case of the operator "[]": simplest smart pointers for byte buffers.<br \>
<tt><div class="freebasic">
<span class="com">''&nbsp;operator3.bas</span><br />
<br />
<span class="com">''&nbsp;A&nbsp;smart&nbsp;pointer&nbsp;is&nbsp;an&nbsp;object&nbsp;which&nbsp;behaves&nbsp;like&nbsp;a&nbsp;pointer&nbsp;but&nbsp;does&nbsp;more&nbsp;than&nbsp;a&nbsp;pointer:</span><br />
<span class="com">''&nbsp;-&nbsp;This&nbsp;object&nbsp;is&nbsp;flexible&nbsp;as&nbsp;a&nbsp;pointer&nbsp;and&nbsp;has&nbsp;the&nbsp;advantage&nbsp;of&nbsp;being&nbsp;an&nbsp;object,</span><br />
<span class="com">''&nbsp;&nbsp;&nbsp;like&nbsp;constructor&nbsp;and&nbsp;destructor&nbsp;called&nbsp;automatically.</span><br />
<span class="com">''&nbsp;-&nbsp;Therefore,&nbsp;the&nbsp;destructor&nbsp;of&nbsp;the&nbsp;smart&nbsp;pointer&nbsp;will&nbsp;be&nbsp;automatically&nbsp;called</span><br />
<span class="com">''&nbsp;&nbsp;&nbsp;when&nbsp;this&nbsp;object&nbsp;goes&nbsp;out&nbsp;of&nbsp;scope,&nbsp;and&nbsp;it&nbsp;will&nbsp;delete&nbsp;the&nbsp;user&nbsp;pointer.</span><br />
<br />
<span class="com">''&nbsp;Example&nbsp;of&nbsp;simplest&nbsp;smart&nbsp;pointers&nbsp;for&nbsp;byte&nbsp;buffers:</span><br />
<span class="com">''&nbsp;-&nbsp;Constructor&nbsp;and&nbsp;destructor&nbsp;allow&nbsp;to&nbsp;allocate,&nbsp;deallocate,&nbsp;and&nbsp;resize&nbsp;the&nbsp;byte&nbsp;buffer.</span><br />
<span class="com">''&nbsp;-&nbsp;Pointer&nbsp;index&nbsp;operator&nbsp;allows&nbsp;to&nbsp;access&nbsp;buffer&nbsp;elements.</span><br />
<span class="com">''&nbsp;-&nbsp;Copy-constructor&nbsp;and&nbsp;let-operator&nbsp;are&nbsp;just&nbsp;declared&nbsp;in&nbsp;private&nbsp;section,</span><br />
<span class="com">''&nbsp;&nbsp;&nbsp;in&nbsp;order&nbsp;to&nbsp;disallow&nbsp;copy&nbsp;construction&nbsp;and&nbsp;any&nbsp;assignment.</span><br />
<br />
<span class="key">Type</span>&nbsp;<span class="wrd">smartByteBuffer</span><br />
&nbsp;&nbsp;<span class="key">Public</span><span class="oth">:</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">size</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">UInteger</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span><span class="oth">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="oth">[]</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">UInteger</span><span class="oth">)</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Byte</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Destructor</span>&nbsp;<span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">Private</span><span class="oth">:</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Constructor</span>&nbsp;<span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">smartByteBuffer</span><span class="oth">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Declare</span>&nbsp;<span class="key">Operator</span>&nbsp;<span class="key">Let</span>&nbsp;<span class="oth">(</span><span class="key">ByRef</span>&nbsp;<span class="wrd">rhs</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">smartByteBuffer</span><span class="oth">)</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Byte</span>&nbsp;<span class="key">Ptr</span>&nbsp;<span class="wrd">psbb</span><br />
<span class="key">End</span>&nbsp;<span class="key">Type</span><br />
<br />
<span class="key">Constructor</span>&nbsp;<span class="wrd">smartByteBuffer</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">size</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">UInteger</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="wrd">This.destructor</span><span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">If</span>&nbsp;<span class="wrd">size</span>&nbsp;<span class="oth">&gt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="key">Then</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="wrd">This.psbb</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="key">New</span>&nbsp;<span class="key">Byte</span><span class="oth">[</span><span class="wrd">size</span><span class="oth">]</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">"Byte&nbsp;buffer&nbsp;allocated"</span><br />
&nbsp;&nbsp;<span class="key">End</span>&nbsp;<span class="key">If</span><br />
<span class="key">End</span>&nbsp;<span class="key">Constructor</span><br />
<br />
<span class="key">Operator</span>&nbsp;<span class="wrd">smartByteBuffer.</span><span class="oth">[]</span>&nbsp;<span class="oth">(</span><span class="key">ByVal</span>&nbsp;<span class="wrd">index</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">UInteger</span><span class="oth">)</span>&nbsp;<span class="key">ByRef</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Byte</span><br />
&nbsp;&nbsp;<span class="key">Return</span>&nbsp;<span class="wrd">This.psbb</span><span class="oth">[</span><span class="wrd">index</span><span class="oth">]</span><br />
<span class="key">End</span>&nbsp;<span class="key">Operator</span><br />
<br />
<span class="key">Destructor</span>&nbsp;<span class="wrd">smartByteBuffer</span>&nbsp;<span class="oth">()</span><br />
&nbsp;&nbsp;<span class="key">If</span>&nbsp;<span class="wrd">This.psbb</span>&nbsp;<span class="oth">&gt;</span>&nbsp;<span class="num">0</span>&nbsp;<span class="key">Then</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Delete</span><span class="oth">[]</span>&nbsp;<span class="wrd">This.psbb</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="wrd">This.psbb</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="quo">"Byte&nbsp;buffer&nbsp;deallocated"</span><br />
&nbsp;&nbsp;<span class="key">End</span>&nbsp;<span class="key">If</span><br />
<span class="key">End</span>&nbsp;<span class="key">Destructor</span><br />
<br />
<span class="key">Scope</span><br />
&nbsp;&nbsp;<span class="key">Dim</span>&nbsp;<span class="key">As</span>&nbsp;<span class="wrd">smartByteBuffer</span>&nbsp;<span class="wrd">sbb</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">smartByteBuffer</span><span class="oth">(</span><span class="num">256</span><span class="oth">)</span><br />
&nbsp;&nbsp;<span class="key">For</span>&nbsp;<span class="wrd">I</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="key">To</span>&nbsp;<span class="num">255</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="wrd">sbb</span><span class="oth">[</span><span class="wrd">I</span><span class="oth">]</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="wrd">I</span>&nbsp;<span class="oth">-</span>&nbsp;<span class="num">128</span><br />
&nbsp;&nbsp;<span class="key">Next</span>&nbsp;<span class="wrd">I</span><br />
&nbsp;&nbsp;<span class="key">Print</span><br />
&nbsp;&nbsp;<span class="key">For</span>&nbsp;<span class="wrd">I</span>&nbsp;<span class="key">As</span>&nbsp;<span class="key">Integer</span>&nbsp;<span class="oth">=</span>&nbsp;<span class="num">0</span>&nbsp;<span class="key">To</span>&nbsp;<span class="num">255</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;<span class="key">Print</span>&nbsp;<span class="key">Using</span>&nbsp;<span class="quo">"#####"</span><span class="oth">;</span>&nbsp;<span class="wrd">sbb</span><span class="oth">[</span><span class="wrd">I</span><span class="oth">];</span><br />
&nbsp;&nbsp;<span class="key">Next</span>&nbsp;<span class="wrd">I</span><br />
&nbsp;&nbsp;<span class="key">Print</span><br />
<span class="key">End</span>&nbsp;<span class="key">Scope</span><br />
</div></tt><br />
</div><div class="fb_sect_title">Dialect Differences</div><div class="fb_sect_cont"><br \>
<ul><li> Only available in the <i><a href="CompilerOptlang.html">-lang fb</a></i> dialect.<br \>
<br \>
</ul></div><div class="fb_sect_title">See also</div><div class="fb_sect_cont"><br \>
<ul><li> <tt><a href="KeyPgClass.html">Class</a></tt><br \>
<li> <tt><a href="KeyPgClass.html">Enum</a></tt><br \>
<li> <tt><a href="KeyPgType.html">Type</a></tt><br \>
<br \>
</ul></div>
</div>
</div> 
</div> 
</body>
</html>
