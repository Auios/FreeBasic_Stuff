#include "header.bi"
randomize timer

dim shared as clientProp cl(SERVER_MAXPLAYERS) '?

'LeServer
'ok first we create the socket and initialize wshelper
hstart()

Sv.Sock = hOpen()
Sv.Port = 5018
Sv.HostIP = "108.75.36.55"

'so now we need to bind the socket to the port
'and set the socket as "listening"

hBind(Sv.Sock, Sv.Port)
hListen(Sv.Sock)

'here we can start the main server loop
'because we want to be able to receive messages
'and accept connections without needing threads

'hSelect(socket,0) 'will return true if can read
'hSelect(socket,1) '(or any number that isnt zero) will return true if can write
'Okay I see so omitting the second parameter means check for read
'which is what you want to do most of times
'Okay. Also (I want to keep all these comments incase I need to look back on this someday.)

' *** user internally by hSendToAll ***
sub SendMessageToAllExcept(ExceptID as integer,pData as any ptr,iSize as integer)
    for iSlot as integer = 0 to SERVER_MAXPLAYERS-1
        with cl(iSlot)
            if .iInUse andalso .iIsAuth andalso iSlot<>ExceptID then
                cptr(MessageHeader ptr,pData)->iSize = iSize
                while hSelect(.socket,1)=0 'write check
                    sleep 1,1 'not saturate connection
                wend
                hSend(.socket,pData,iSize)
            end if
        end with
    next iSlot
end sub
' *************************************
sub FreeClient(iSlot as integer)
    with cl(iSlot)
        Print "Client Disconnected: " & (iSlot)
        hClose(.Socket) 'close socket even if disconnected to not have ghost sockets
        .Socket=0 'emtpy the variable to avoid trash on memory
        deallocate(.pBuff) 'dealocate the message buffer
        .Pbuff=0 'empty the pointer to avoid having bad pointers on memory
        .iInUse=0 'Client Slot is now free!
        .iIsAuth=0 'Client is not auth anymore!
        'more things to do when client disconnected?
        'send part message to everybody
        dim as tMessagePart tPart
        tPart.ID = iSlot
        hSendToAll(tPart)
    end with
end sub

sub AddClient(iSlot as integer)
    with cl(iSlot)
        .iInUse=1
        print "Client Connected: " & (iSlot)
        .Socket = hAccept(Sv.Sock) 'get sock/ip/port is all here!
        'more initial  data (generated by server)
        .pBuff = allocate(MAX_MESSAGE_SIZE) 'buffer for each client
        .iMsgSz = 0 'clear message 'reading size'
        .iMsgRead = 0        
    end with
end sub

sub CheckNewClients()
    if hSelect(Sv.Sock)<>0 then 'Client Connected.
        dim as integer iSlot
        'locating a free slot for the new client
        for iSlot = 0 to SERVER_MAXPLAYERS-1
            if cl(iSlot).iInUse=0 then 'found free slot
                exit for
            end if
        next iSlot
        if iSlot >= SERVER_MAXPLAYERS then 'Server Full
            'exactly, i would leave it for later but let's do it now :)
            'Also after they connected. I want to send a "Chat message" or something to them saying
            '"Server full" or something.
            'then disconnect them. yes that you can do later
            'make temp connection 
            'send error message and disconnect
            var SockTemp = hAccept(Sv.Sock)
            dim as tMessageError tErr
            tErr.sMessage = "Server Full..."
            print "Client " & (iSlot) & " Disconnected: Server Full..."
            hSendStruct(SockTemp,tErr)
            hClose(SockTemp)
            exit sub'Here we have to make the player connect and then disconnect ya?
        end if
        'Adding a new Client
        AddClient(iSlot)
    end if
end sub

sub ProcessClientMessage(iSlot as integer,pMsg as MessageHeader ptr)
    select case pMsg->iType 'what kind of message the client is sending? '
    case mtSign 'client is signing
        with cl(iSlot)
            .tInfo = cptr(tMessageSign ptr,pMsg)->tInfo
            
            print "Client #" & iSlot & " signed " & .iIsAuth
            if .iIsAuth = 0 then
                .iIsAuth = 1 'client signed in
                'Send names/ID/position of everybody already on the session
                var SockTemp = .Socket
                for i as integer = 0 to SERVER_MAXPLAYERS-1
                    with cl(i)
                        if .iInUse andalso .iIsAuth AndAlso i<>iSlot then
                            while hSelect(SockTemp,1)=0 'write check
                              sleep 1,1 'not saturate connection
                            wend
                            dim as tMessageJoin tJoin
                            tJoin.ID = i
                            tJoin.sign = .tInfo.sign
                            hSendStruct(SockTemp,tJoin)
                            dim as tMessageUpdatePostion tNewPos
                            tNewPos.ID = i
                            tNewPos.tData = .tData
                            
                            for j as integer = 0 to SERVER_MAXPLAYERS-1
                                if tJoin.ID <> j andalso tJoin.sign = cl(j).tInfo.sign then
                                    dim as tMessageError tErr
                                    tErr.sMessage = "Name taken..."
                                    print "Client " & (iSlot) & " Disconnected: Name taken..."
                                    hSendStruct(SockTemp,tErr)
                                    hClose(SockTemp)
                                end if
                            next j
                            
                            hSendStruct(SockTemp,tNewPos)
                        end if
                    end with 
                next i                        
                'and then Send Confirmation to client and his ID
                'so sending details of everybody allows the client
                'to supress the message saying that player "joined"
                'alternatively we could use yet another message to 
                'update everything but for now i will just send
                'two messages per other client... No I mean why not make another message?
                'because this message would be a variable size message a
                'Ok, because we would only send the clients not the whole list
                'also we have a low limit on message buffer, so sending in parts is ok :)
                'Alright :3 'those are things that are optional and you can change later at will
                'as there several different ways of doing the same thing
                dim as tMessageSignReply tReply
                tReply.ID = iSlot
                print "Client #" & iSlot & " sending ID:" & iSlot
                hSendStruct(.Socket,tReply)
                
                'And Spread the JOIN message to others
                dim as tMessageJoin tJoin
                tJoin.ID = iSlot
                tJoin.sign = .tInfo.sign
                hSendToAll(tJoin)
            end if
        end with   
    case mtPosition 'client changed position        
        with *cptr(tMessageUpdatePostion ptr,pMsg)
            print "Client #" & (iSlot) & " New Position: " & .tData.x & "," & .tData.y
            .ID = iSlot
            cl(iSlot).tData = .tData
            'Forwaring the message to other players
            hSendToAll( *cptr(tMessageUpdatePostion ptr,pMsg) )
        end with
    case mtChat 'client send chat text
        with *cptr(tMessageChat ptr,pMsg)
            print "Client " & iSlot & " Said: '"+.sMessage
        end with
    end select
    'so here all the server action happens
    'it checks the message type and do  one action based on that
    'like after reading the chat text message
    'you probabily want to issue a "Server Message" to all
    'client that will propagate that chat message to everybody
    'So we need a send to all sub? yes but for now let's just keep it
    'this way otherwise we wont finish this thing ever :P
    'Right xD
    
    'still alive? :P
    'duuu yep :D ok almost done
    'you're following more or less what i'm doing?
    'I understand what everything you are doing DOES. But I could not
    'reproduce it on my own. I could probably edit it to my needs, and over time I
    'Would let it sink in until it goes *click* into my mind.
    'ok yeah because we did some 'advanced' a little more complex than it can be server
    'but is a very solid one :P
    
    'I was gonna let my friends and I work out the bugs xD I just wanted
    'Something to build off of. but this is cool too. yeah well guess it also makes
    'you learn tons of things about coding in all respects, because what we're doing
    'has really little to do with network, and a lot more todo with generalities
    'but i tend to do things in a not so simple for normal people way ;p
    
    'Well you are MySoft :) 'ok nwe just need to spread the "Client Part" message
    'and spread the player position message and we're set
    'Woot!
end sub

#if 0  'deal with this later :P
ok since we have this type of message the best
is to make a buffer per clientotherwise if we use a single buffer
to wait for messages we would end hanging the app
if the message gets split in to packets for examples
and we don't w want that right? Right.so i will put the vars
i allocated earlier in the client structure as well
#endif

print "~LeServer~"
do
    CheckNewClients() 'can be this way? better organized. Yes I love subs.

    'so about accepting clients that's all
    'now we must process the messages. Alright. I am learning a lot :)
    for iSlot as integer = 0 to SERVER_MAXPLAYERS-1
        with cl(iSlot)
            if .Socket=0 or .iInUse=0 then continue for 'ignore if no client on slot
        'so i will explain what i'm doing here because it's important
        'i will first try to read a "header" so you know the size
        'that the total of the message have and then i will only
        '"process the message" when it's fully read        
            while hSelect(.Socket) 'there's data to read? 1=Yes,  0 = no?
                if .iMsgSz=0 then 'read header (to avoid exploits)
                    'print "Reciving Message Header from " & (iSlot) & " read: " & .iMsgRead                    
                    var iResu = hreceive(.Socket,.pBuff+.iMsgRead,sizeof(MessageHeader)-.iMsgRead)
                    if iResu < 0 then 'Client Disconnected
                        FreeClient(iSlot):continue for 'nothing more too with this client
                    end if
                    .iMsgRead += iResu
                    if .iMsgRead >= sizeof(MessageHeader) then
                        if cptr(MessageHeader ptr,.pBuff)->iHash <> &hFF01EE02 then
                            print "Invalid Message Sent??????"
                            sleep: end
                        end if
                        ' print "Reciving Message from " & (iSlot) & _
                        ' " type: " & cptr(MessageHeader ptr,.pBuff)->iType & _
                        ' " size: " & cptr(MessageHeader ptr,.pBuff)->iSize
                        .iMsgSz = cptr(MessageHeader ptr,.pBuff)->iSize 'Get Message Full Size                        
                    end if
                end if                
                if .iMsgSz>0 then 'read rest of message (after safely read the header of it)
                    'print "Reciving Message from " & (iSlot) & " read: " & .iMsgRead
                    var iResu = hreceive(.Socket,.pBuff+.iMsgRead,.iMsgSz-.iMsgRead)
                    if iResu < 0 then 'Client Disconnected
                        FreeClient(iSlot):continue for 'nothing more too with this client
                    end if
                    .iMsgRead += iResu
                    if .iMsgRead >= sizeof(MessageHeader) then
                        ProcessClientMessage(iSlot,.pBuff)
                        .iMsgSz=0:.iMsgRead=0
                    end if
                end if
            wend
        end with
    next iSlot
    sleep 1,1 'to not let the server go 100% cpu
    ' more server processing here?
    
    'let's make the server send a circle position to everybody 
    'at period interval like 20fps also called "Server FPS"
    static as double SvSync
    if abs(timer-SvSync) > 1 then SvSync = timer 'tolerance on delay
    while (timer-SvSync) >= 1/SERVER_FPS
        'Things that happens at SERVER FPS
        #if 0 'commented this as it's not suppose to move on it's own :)
        static as integer iAngle
        iAngle = (iAngle+13) mod 360
        'Angle? is just to make the circle do something you will se :P
        'Are we gonna make the circle rotate? ya 
        'Oh well. I just said circles because it was simple.
        'I was gonna replace the circles with squares.
        'still is very simple, and since we must do something making them
        'rotate for testin isnt big deal anyway :) Okaaay :)
        dim as tMessageUpdatePostion tNewPos
        tNewPos.tData.X = 320+sin(iAngle*PI180)*200
        tNewPos.tData.Y = 240+cos(iAngle*PI180)*200
        tNewPos.tData.iColor = rgba(255,128,64,0)
        for iSlot as integer = 0 to SERVER_MAXPLAYERS-1
            with cl(iSlot)
                if .iIsAuth=0 or .iInUse=0 then continue for 'ignore if free
                tNewPos.ID = iSlot
                hSendStruct(.Socket, tNewPos)
            end with 'it ended on it's own? No. I added the escape to end loop.
        next iSlot
        #endif
        SvSync += 1/SERVER_FPS 'i.e. 1/20s per iteration
    wend
    
    'Ok. Question: Is the client going to send the data to the server,
    'then the server sends it to everyone + user it was sent to. OR
    
    'The data is sent to the server, but the client also uses the same data for
    'its own personal usage. This means we need to make the send to all sub
    'Not send the data back to the client it got the data from.
    'yeah the client will use the data it's sending so it will not receive it back
    'and yes the server propagates the message =to others playes if required
    '
    'My friend who is also a programmer told me about the first option.
    'He said he never uses the 2nd one, because it's a security hazzard.
    'People could use cheat engine to change their location or something...
    'But I dont think I have to worry about it. Just curious. ha yeah
    'well just not receiving it back isnt a hazard per se but, it could improve
    'security in some cases, but i think what he is talking about
    'is about movement and other kind of data that you better let the server
    'process and return then do the user (like the client just send the movment
    'not a "hit" or something like that, but there's dozen of ways
    'and a lot of things that are problematic indeed, for us, here that is
    'perfectly fine :) Okay :)
    
    
loop until multikey(sc_escape)
'and this is it for the server for now hehehe
'Sheesh :P I have a lot more than I expected to understand fully. Thanks for your notes :)
'
'yeah well we ended making a more advanced server right from start
'because it's better than growing it up part by part
'it would be very ugly without making this first step in a consistent manner
'so the client is basically the same as this server
'except it wont have the part that manages the clients
'it just connect, send the sign structure
'and start receiving messages which will include the circle update
'oh i forgot one little thing here
'ok let's try to compile
'to see how many syntax errors i did :P Sure!
'that's it i guess :)